\documentclass[12pt,a4paper]{article}
\usepackage{mainsty}
\begin{document}
  \begin{center}
    \large\textsc{Comp 333 Midterm}
  \end{center}
  \begin{enumerate}
    \item Name one reason why someone might want to use \imp{virtual dispatch}. % 1
    \begin{itemize}
      \item Allows for same method call to have different behaviors at runtime, which is more flexible.
      \item Allows for abstraction over code behavior. Calling code only needs to know the signature of a method, and the runtime behavior can be dynamically changed by changing the underlying object the method is called on.
      \item Improves code modularity. Each distinct behavior can be isolated from each other behavior, and behaviors generally don't need to know about each other.
    \end{itemize}
    \item Name one reason why someone might not want to use \imp{virtual dispatch}. % 2
    \begin{itemize}
      \item Code can become more bloated. Usually, multiple classes have to be introduced, and these all have their own boilerplate associated with them.
      \item Code's behavior can become less explicit, and potentially more difficult to reason about.
      \begin{itemize}
        \item For example, an if/else clearly indicates a condition to test and code to execute depending on the condition. However, a method call may implicitly do something similar.
      \end{itemize}
      \item It generally has worse performance than an explicit if/else.
      \begin{itemize}
        \item Behind the scenes, indirect jumps are often needed, and these can easily jump out of cached instructions. Moreover, it's difficult to predict where an indirect jump will go.
      \end{itemize}
    \end{itemize}
    \clearpage
    \item Consider the following Java code: % 3
    \begin{itemize}
      \item[] \lstinputlisting[language=Java,firstline=2,lastline=12]{java/Main.java}
      \item[] \lstinputlisting[language=Java,firstline=2,lastline=4]{java/I1.java}
      \item[] \lstinputlisting[language=Java,firstline=3,lastline=7]{java/C1.java}
      \item[] \lstinputlisting[language=Java,firstline=3,lastline=7]{java/C2.java}
      \item[] What is the output of the main method? 
      \begin{itemize}
        \item[] c1\\c2
      \end{itemize} 
    \end{itemize}
    \clearpage
    \item Consider the following code snippet: % 4
    \begin{itemize}
      \item[] \lstinputlisting[language=Java,firstline=2,lastline=12]{java/pr4/Main.java}
      \item[] Define any interfaces and/or classes necessary to make this snippet print 8, followed by 2. 
    \end{itemize}
    \clearpage
    \item Consider the following Java code, which simulates a lock which can be either locked or
    unlocked. The lock is an immutable data structure, so locking or unlocking returns a new lock
    in an appropriate state: Refactor this code to use virtual dispatch, instead of using if/else. As a hint, you should have a
    base class/interface for Lock, and subclasses for locked and unlocked locks. (Continued on to
    next page) % 5
    \begin{itemize}
      \item[] \lstinputlisting[language=Java,firstline=3,lastline=29]{java/pr5/Lock.java}
      \item[] Refactor this code to use virtual dispatch, instead of using if/else. As a hint, you should have a
      base class/interface for Lock, and subclasses for locked and unlocked locks. (Continued on to
      next page) 
    \end{itemize}
    \clearpage
    \item The code below does not compile. Why? % 6
    \begin{itemize}
      \item[] \lstinputlisting[language=Java,firstline=3,lastline=10]{java/pr6/MyClass.java}
      \item[] \lstinputlisting[language=Java,firstline=3,lastline=10]{java/pr6/MyInterface.java}
    \end{itemize}
    \clearpage
    \item Java supports sub-typing. Write a Java code snippet that compiles and uses sub-typing. % 7
    \begin{itemize}
      \item 
    \end{itemize} 
    \item Name one reason why someone might prefer \imp{static typing} over dynamic typing. % 8
    \begin{itemize}
      \item 
    \end{itemize}
    \item Name one reason why someone might prefer \imp{dynamic typing} over static typing. % 9
    \begin{itemize}
      \item 
    \end{itemize}
    \item Name one reason why someone might prefer \imp{strong typing} over weak typing. % 10
    \begin{itemize}
      \item Strongly-type languages are more predictable, especially in the presence of bugs and errors.
      \item Strongly-type languages tend to emphasize code correctness.
    \end{itemize}
    \item Name one reason why someone might prefer \imp{weak typing} over strong typing. % 11
    \begin{itemize}
      \item No need for runtime array bounds check, so performance benefit.
      \item Weakly-typed languages tend to be more expressive. 
      \begin{itemize}
        \item C lets you do more than Java in terms of low-level manipulation, but its easy to hit undefined behavior, meaning programs lose all meaning.
        \item This can happen even when the code appears to be working correctly.
      \end{itemize}
    \end{itemize}
  \end{enumerate}
\end{document}